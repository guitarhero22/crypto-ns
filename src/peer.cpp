#include <set>
#include "peer.h"

// Link
Link::Link(Peer *_src, Peer *_tgt): src(_src), tgt(_tgt)
{
    p = _unif_real<Ticks>(10, 500);
    c = (src->is_slow() || tgt->is_slow()) ? 5 : 100;
    rng = std::mt19937((std::random_device())());
    d = std::exponential_distribution<Ticks>(c / 96.0);
}

Event* Link::send(Msg *msg, Ticks sendTime)
{
    if(src == NULL || tgt == NULL) {
        std::cerr << "Link not initialized properly" << std::endl;
    }
    Ticks delay = 0;
    delay += p;
    delay += msg -> size / c;
    delay += d(rng);
    std::cout << src -> ID << " sending to " << tgt -> ID << " will reach at " << sendTime + delay << std::endl;

    Q.push(pTM({sendTime + delay, msg})); // push to queue to send later

    return new Event(sendTime + delay, this, reinterpret_cast<callback_t> (&Link::sent));
}

std::vector<Event*> Link::sent(Ticks sentTime){

    if(Q.empty()) logerr("Link::sent msg Queue Empty");

    auto msg = Q.top();
    if(msg.first != sentTime) logerr("Link::sent sentTime not equal to message time");

    Q.pop(); 

    return (*tgt).rcvMsg(src, msg.second, sentTime);
}

// Peer
std::vector<Event*> Peer::INIT(std::vector<Peer> &peers){
        std::vector<Event*> initEvents;

        return initEvents;
};

Peer::Peer(ID_t id, Ticks txnMean, Ticks computePower, bool _slow) : slow(_slow), ID(id)
{
    rng = std::mt19937((std::random_device())());
    nextTxnTime = std::exponential_distribution<Ticks>(1/txnMean);
    nextBlkTime = std::exponential_distribution<Ticks>(1/computePower);
}

std::vector<Event *> Peer::rcvMsg(Peer *src, Msg *msg, Ticks rcvTime){
    std::vector<Event*> ret;
    if(msg -> type == BLOCK){
        ret = rcvBlk(src, static_cast<Blk*>(msg), rcvTime);
    }
    else if(msg -> type == TXN){
        ret = rcvTxn(src, static_cast<Txn*>(msg), rcvTime);
    }
    else logerr("Peer::rcvMsg msg Type none of BLOCK or TXN");

    return ret;
}

//Peer Receivs Txn
std::vector<Event *> Peer::rcvTxn(Peer *src, Txn *txn, Ticks rcvTime)
{
    if(src != this)
        std::cout << "Txn Recvd by " << ID << " at " << rcvTime << std::endl;

    std::vector<Event *> ret;

    if (tree.addTxn(txn))
        return ret;

    for (auto &l : links)
    {
        if (src != NULL && l.first->ID == src->ID)
            continue;
        ret.push_back(l.second.send(txn, rcvTime));
    }

    return ret;
}


//Peer Generates Transactions
std::vector<Event *> Peer::genTxn(Ticks genTime)
{
    // ! Add Logic for selection of TXN Amount
    int send_to = _unif_int<ID_t>(0, NUM_PEERS - 1);
    Txn *txn = Txn::new_txn(ID, send_to, 50, genTime);
    std::cout << "Txn "<< txn -> ID << " Generated by " << ID << " at " << genTime  << std::endl;
    auto ret = rcvTxn(this, txn, genTime);

    ret.push_back(new Event(genTime + nextTxnTime(rng), this, reinterpret_cast<callback_t> (&Peer::genTxn)));

    return ret;
}

//Peer Generates Block
std::vector<Event *> Peer::genBlk(Ticks startTime, Ticks genTime, BID_t parent)
{
    std::vector<Event*> ret; 
    return ret;

    if(startTime < miningSessionStart) return ret;

    Blk *blk = Blk::new_blk(forNxtBlk, parent, genTime);
    if(!tree.insert(blk, true)){
        // Could not insert the block
    }else{

    }

    //can generate the next block
    // ret.push_back(new PeerGenBlk(this, genTime, genTime + nextBlkTime(rng), tree.getLastId()));

    //Update Txn Pools 
    //Broadcast Blocks
}

std::vector<Event *> Peer::rcvBlk(Peer * src, Blk *blk, Ticks rcvTime)
{
    std::vector<Event*> ret;
    return ret;
}

void ConnectGraphByRandomWalk(std::vector<Peer> &peers)
{
    std::set<Peer *> peer_set;

    unsigned int n = peers.size();
    for (int i = 0; i < n; ++i)
        peer_set.insert(&peers[i]);

    std::mt19937 rng((std::random_device())());
    std::uniform_int_distribution<unsigned int> select(0, n - 1);

    unsigned int current = 0;
    peer_set.erase(&peers[current]);
    while (!peer_set.empty())
    {

        unsigned int next = select(rng);

        if (current == next)
            continue;

        auto &nbrs = peers[current].links;
        if (nbrs.find(&peers[next]) != nbrs.end())
        {
            current = next;
            continue;
        }

        peer_set.erase(&peers[next]);
        nbrs[&peers[next]] = Link(&peers[current], &peers[next]);
        peers[next].links[&peers[current]] = Link(&peers[next], &peers[current]);

        current = next;
    }

    return;
}