#include <set>
#include "peer.h"

// Link
Link::Link(Peer *_src, Peer *_tgt) : src(_src), tgt(_tgt)
{
    p = _unif_real<Ticks>(10, 500);
    c = (src->is_slow() || tgt->is_slow()) ? 5 : 100;
    rng = std::mt19937((std::random_device())());
    d = std::exponential_distribution<Ticks>(c / 96.0);
}

Event *Link::send(Msg *msg, Ticks sendTime)
{
    if (src == NULL || tgt == NULL)
        logerr("Link not initialized properly");

    Ticks delay = 0;
    delay += p;
    delay += msg->size / c;
    delay += d(rng);
    Ticks aod = sendTime + delay;

    // log(tos(src->ID) + " sending to " + tos(tgt->ID) + " will reach at " + tos(aod) + " Msg Size: " + tos(msg->size));

    Q.push(pTM({aod, msg})); // push to queue to send later

    return new Event(aod, this, reinterpret_cast<callback_t>(&Link::sent));
}

std::vector<Event *> Link::sent(Ticks sentTime, EID_t eid)
{

    if (Q.empty())
        logerr("Link::sent msg Queue Empty");

    auto msg = Q.top();

    if (std::abs(msg.first - sentTime) > Ticks(1e-6))
        logerr("Link::sent sentTime not equal to message time: MSG_TYPE = " + std::to_string(msg.second->type) + " time in msg=" + std::to_string(msg.first) + " sentTime=" + std::to_string(sentTime));

    Q.pop();

    return (*tgt).rcvMsg(src, msg.second, sentTime);
}

// Peer
std::vector<Event *> Peer::INIT(std::vector<Peer> &peers)
{
    int sz = peers.size();
    std::vector<Event *> initEvents(2 * sz, NULL);
    for (int i = 0; i < sz; ++i)
    {
        initEvents[i] = new Event(peers[i].nextTxnTime(peers[i].rng), &peers[i], reinterpret_cast<callback_t>(&Peer::genTxn));
        initEvents[i + sz] = peers[i].start_mining_session(0);
    }

    Tree::INIT();
    return initEvents;
    log("Peers Initialized");
};

Peer::Peer(ID_t id, Ticks txnMean, Ticks computePower, bool _slow) : slow(_slow), ID(id), tree(Tree(id))
{
    rng = std::mt19937((std::random_device())());
    nextTxnTime = std::exponential_distribution<Ticks>(1 / txnMean);
    nextBlkTime = std::exponential_distribution<Ticks>(1 / computePower);
}

std::vector<Event *> Peer::rcvMsg(Peer *src, Msg *msg, Ticks rcvTime)
{
    std::vector<Event *> ret;
    if (msg->type == BLOCK)
    {
        ret = rcvBlk(src, static_cast<Blk *>(msg), rcvTime);
    }
    else if (msg->type == TXN)
    {
        ret = rcvTxn(src, static_cast<Txn *>(msg), rcvTime);
    }
    else
        logerr("Peer::rcvMsg msg Type none of BLOCK or TXN");

    return ret;
}

//Peer Receivs Txn
std::vector<Event *> Peer::rcvTxn(Peer *src, Txn *txn, Ticks rcvTime)
{
    // if (src != this)
    // log("Txn Recvd by " + tos(ID) + " at " + tos(rcvTime));

    std::vector<Event *> ret;

    if (!tree.addTxn(txn))
        return ret;

    for (auto &l : links)
    {
        if (src != NULL && l.first->ID == src->ID)
            continue;
        ret.push_back(l.second.send(txn, rcvTime));
    }

    return ret;
}

//Peer Generates Transactions
std::vector<Event *> Peer::genTxn(Ticks genTime, EID_t eid)
{
    // ! Add Logic for selection of TXN Amount
    int send_to = _unif_int<ID_t>(0, NUM_PEERS - 1);
    Txn *txn = Txn::new_txn(ID, send_to, 50, genTime);
    // log("Txn " + tos(txn->ID) + " Generated by " + tos(ID) + " at " + tos(genTime));
    auto ret = rcvTxn(this, txn, genTime);

    ret.push_back(new Event(genTime + nextTxnTime(rng), this, reinterpret_cast<callback_t>(&Peer::genTxn)));

    return ret;
}

Event *Peer::start_mining_session(Ticks startTime)
{
    // log("Peer::start_mining_session " + std::to_string(ID) + " Peer starts Mining");
    mining_on = tree.startMining(ID, startTime);
    Ticks genTime = startTime + nextBlkTime(rng);
    callback_t cb = reinterpret_cast<callback_t>(&Peer::genBlk);
    Event *genBlkEvent = new Event(genTime, this, cb);
    mining_event = genBlkEvent->ID;
    return genBlkEvent;
};

std::vector<Event *> Peer::rcvBlk(Peer *src, Blk *blk, Ticks rcvTime)
{

    // if (src != this)
    // log("Blk Recvd by " + tos(ID) + " at " + tos(rcvTime));

    std::vector<Event *> ret;
    int what_should_I_do_with_it_LOL = tree.addBlk(blk, rcvTime);

    if (what_should_I_do_with_it_LOL == DONT_SEND || what_should_I_do_with_it_LOL == DONT_KNOW)
    {
        return ret;
    }

    if (what_should_I_do_with_it_LOL == NEW_LONGEST_CHAIN)
    {
        ret.push_back(start_mining_session(rcvTime)); //start new mining session
    }

    for (auto &l : links)
    {
        if (src != NULL && l.first->ID == src->ID)
            continue;
        ret.push_back(l.second.send(blk, rcvTime));
    }

    return ret;
}

//Peer Generates Block
std::vector<Event *> Peer::genBlk(Ticks genTime, EID_t eid)
{
    std::vector<Event *> ret;

    //Check if this mining session was abandoned
    if (eid != mining_event)
    {
        // log("Mining already started for another block");
        return ret;
    }

    //Create New Block
    Blk *blk = tree.mineBlk(ID, mining_on, genTime);
    // log("Block Generated by " + std::to_string(ID) + ", blk size = " + std::to_string(blk->size));

    //BroadCast new Block
    ret = rcvBlk(this, blk, genTime);

    //Start Mining Session for the next block
    // Event *nxtEvent = start_mining_session(genTime);
    // if (nxtEvent != NULL)
    // ret.push_back(nxtEvent);
    // else
    // logerr("Peer::genBlk nxtEvent is NULL");

    return ret;
}

void ConnectGraphByRandomWalk(std::vector<Peer> &peers)
{
    std::set<Peer *> peer_set;

    unsigned int n = peers.size();
    for (int i = 0; i < n; ++i)
        peer_set.insert(&peers[i]);

    std::mt19937 rng((std::random_device())());
    std::uniform_int_distribution<unsigned int> select(0, n - 1);

    unsigned int current = 0;
    peer_set.erase(&peers[current]);
    while (!peer_set.empty())
    {

        unsigned int next = select(rng);

        if (current == next)
            continue;

        auto &nbrs = peers[current].links;
        if (nbrs.find(&peers[next]) != nbrs.end())
        {
            current = next;
            continue;
        }

        peer_set.erase(&peers[next]);
        nbrs[&peers[next]] = Link(&peers[current], &peers[next]);
        peers[next].links[&peers[current]] = Link(&peers[next], &peers[current]);

        current = next;
    }

    return;
}